main:

  params: [input]

 

  steps:

    - init:

        assign:

          - project_id: sandbox-dev-478813

          # image_id must be the image NAME from display project, e.g. "schwab-rhel8-110278a-20251111-151440"

          - image_id: ${default(map.get(input, "image_id"), "")}

          - instance_name: ${default(map.get(input, "instance_name"), "")}

          - override_scan_result: ${default(map.get(input, "override_scan_result"), "")}

          - skip_destroy: ${default(map.get(input, "skip_destroy"), false)}

          - skip_promotion: ${default(map.get(input, "skip_promotion"), false)}

          - project_number: ${default(map.get(input, "project_number"), sys.get_env("GOOGLE_CLOUD_PROJECT_NUMBER"))}

          - region: ${default(map.get(input, "region"), "us-central1")}

          - location_id: ${default(map.get(input, "location_id"), "us-central1")}

 

    # Start at validation (no create_build / creation step)

    - validation:

        call: validate_image

        args:

          image_id: ${image_id}

          project_id: ${project_id}

          location_id: ${location_id}

          instance_name: ${instance_name}

          override_scan_result: ${override_scan_result}

        result: validation_results

 

    # Gate: only notify promote workflow if validation passed

    - decide_notification:

        switch:

          - condition: ${validation_results.scan_result == "Pass"}

            next: notify_cleanup_promote_step

        # If not Pass (i.e., Fail), skip Pub/Sub notification and just return result

        next: return_result

 

    # Notify cleanup/promote via Pub/Sub (only reached when scan_result == "Pass")
    # Cloud Function will handle image promotion and cleanup

    - notify_cleanup_promote_step:

        call: notify_cleanup_promote

        args:

          project_id: ${project_id}

          image_id: ${image_id}

          scan_result: ${validation_results.scan_result}

          validation_instance: ${validation_results.validation_instance}

          skip_destroy: ${skip_destroy}

          skip_promotion: ${skip_promotion}

        result: notification_results

        next: wait_for_cleanup_completion

 

    # Wait for Cloud Function to complete VM cleanup

    - wait_for_cleanup_completion:

        switch:

          - condition: ${skip_destroy == true}

            next: return_result

        next: poll_vm_deletion

 

    - poll_vm_deletion:

        call: check_vm_deleted

        args:

          project_id: ${project_id}

          instance_name: ${validation_results.validation_instance}

          max_attempts: 30

          wait_seconds: 10

        result: vm_deletion_status

        next: return_result

 

    - return_result:

        return:

          image_id: ${image_id}

          scan_result: ${validation_results.scan_result}

          validation_instance: ${validation_results.validation_instance}

          # If notification_results is undefined (Fail path), mark as "skipped"

          notification_result: ${default(notification_results, "skipped")}

          # Note: Image promotion and cleanup are handled by Cloud Function

          # Cloud Function subscribes to Pub/Sub topic and processes:

          # 1. Create promoted image from validation VM

          # 2. Cleanup validation VM

          vm_deletion_status: ${default(vm_deletion_status, "skipped")}

 

# -------------------------------------------------------------------

#   NOTIFICATION SUB-WORKFLOW (Pub/Sub trigger for cleanup/promote)

# -------------------------------------------------------------------

 

notify_cleanup_promote:

  params: [project_id, image_id, scan_result, validation_instance, skip_destroy, skip_promotion]

 

  steps:

    - publish_message:

        call: googleapis.pubsub.v1.projects.topics.publish

        args:

          topic: ${"projects/sandbox-dev-478813/topics/schwab-runtime-workflow--promote-topic"}

          body:

            messages:

              - attributes:

                  image_id: ${image_id}

                  scan_result: ${scan_result}

                  validation_instance: ${validation_instance}

                  skip_destroy: ${string(skip_destroy)}

                  skip_promotion: ${string(skip_promotion)}

                  source_workflow: "runtime-validation"

                data: ${base64.encode(text.encode("trigger-cleanup-promote"))}

        result: pubsub_result

 

    - return_pubsub:

        return: ${pubsub_result}

 

# -------------------------------------------------------------------

#   VALIDATION PIPELINE (driven by validate.sh Pass/Fail)

# -------------------------------------------------------------------

 

validate_image:

  params: [image_id, project_id, location_id, instance_name, override_scan_result]

 

  steps:

    # 1) Check override - if pass, create VM but skip validation scripts

    - check_override:

        switch:

          - condition: ${text.to_lower(override_scan_result) == "pass"}

            next: create_vm_override_pass

          - condition: ${text.to_lower(override_scan_result) == "fail"}

            next: return_override_fail

        next: skip_instance_creation

 

    # 2) If a validation instance already exists with the expected name, treat it as already validated

    - skip_instance_creation:

        switch:

          - condition: ${instance_name == image_id + "-validation"}

            next: derive_pass_from_existing

        next: create_instance

 

    # 3) Normal path – create validation VM and run validate.sh (via validation_instance)

    - create_instance:

        call: validation_instance

        args:

          image_id: ${image_id}

          project_id: ${project_id}

          location_id: ${location_id}

        result: validation_output

 

    - assign_results:

        assign:

          - instance_name: ${validation_output.instance_name}

          - scan_result: ${validation_output.scan_result}

        next: return_multiple_values

 

    - return_multiple_values:

        return:

          validation_instance: ${instance_name}

          scan_result: ${scan_result}

 

    # 4) If caller passed in an already-known validation instance, mark it Pass

    - derive_pass_from_existing:

        return:

          validation_instance: ${instance_name}

          scan_result: "Pass"

 

    # 5) Override handlers

    # Create VM when override = "pass" but skip validation scripts

    - create_vm_override_pass:

        call: create_vm_only

        args:

          image_id: ${image_id}

          project_id: ${project_id}

          location_id: ${location_id}

        result: vm_result

        next: return_override_pass

    - return_override_pass:

        assign:

          - instance_name: ${vm_result.instance_name}

          - scan_result: "Pass"

        next: return_multiple_values

 

    - return_override_fail:

        return:

          validation_instance: ${instance_name}

          scan_result: "Fail"

 

# -------------------------------------------------------------------

#   VALIDATION INSTANCE CREATION (Cloud Build)

#   - Creates VM from candidate image

#   - Runs validate.sh (master script)

#   - Uses exit code to decide Pass / Fail

# -------------------------------------------------------------------

 

validation_instance:

  params: [image_id, project_id, location_id]

 

  steps:

    - the_build:

        call: googleapis.cloudbuild.v1.projects.builds.create

        args:

          projectId: ${project_id}

          # Cloud Build v1 "projects.builds.create" is global

          parent: ${"projects/" + project_id + "/locations/global"}

          body:

            source:

              repoSource:

                repoName: "gcp-ansible-playbooks"

                dir: "."

                branchName: "master"

            steps:

              - name: "gcr.io/cloud-builders/gcloud"

                entrypoint: "bash"

                args:

                  - -c

                  - |

                    set -e

 

                    # Instance name derived from image_id

                    INSTANCE_NAME="${_CANDIDATE_IMAGE}-validation"

 

                    echo "Creating validation VM: $${INSTANCE_NAME}"

 

                    # Create validation VM from display-case image

                    gcloud compute instances create "$${INSTANCE_NAME}" \

                      --image=projects/sandbox-dev-478813/global/images/${_CANDIDATE_IMAGE} \

                      --machine-type=n1-standard-1 \

                      --subnet=default \

                      --no-address \

                      --service-account=sa-kitchen-sh@sandbox-dev-478813.iam.gserviceaccount.com \

                      --zone=us-central1-a \

                      --scopes=cloud-platform

 

                    echo "Waiting for VM to be ready..."
                    sleep 30

                    echo "Copying validation scripts to VM..."
                    gcloud compute scp --recurse ./validation/ "$${INSTANCE_NAME}:~/validation" \
                      --zone=us-central1-a \
                      --quiet

                    echo "Running master validation script (validate_all.sh) on VM $${INSTANCE_NAME}..."

 

                    # Master script orchestrates all runtime checks (Python, Node, Java, Postgres, etc.)

                    # It must:

                    #   - exit 0 if ALL runtime checks pass

                    #   - exit non-zero if ANY runtime fails

                    gcloud compute ssh "$${INSTANCE_NAME}" \
                      --zone=us-central1-a \
                      --command="cd ~/validation && chmod +x *.sh && bash validate_all.sh" \
                      --quiet > validation.log 2>&1

                    VALIDATION_EXIT_CODE=$?

 

                    if [ $${VALIDATION_EXIT_CODE} -eq 0 ]; then

                      VALIDATION_RESULT="Pass"

                      echo "VALIDATION: PASS"

                    else

                      VALIDATION_RESULT="Fail"

                      echo "VALIDATION: FAIL (exit code: $${VALIDATION_EXIT_CODE})"

                    fi

 

                    # Emit combined JSON (instance_name + scan_result) to Cloud Build output

                    # Cloud Workflows will parse this.

                    echo "{\"instance_name\":\"$${INSTANCE_NAME}\",\"scan_result\":\"$${VALIDATION_RESULT}\"}" > "$$BUILDER_OUTPUT/output"

 

            substitutions:

              _CANDIDATE_IMAGE: ${image_id}

            options:

              dynamic_substitutions: true

            tags:

              - "schwab-rhel8"

              - "validation_instance"

        result: the_buildResults

 

    - decode_build_result:

        assign:

          - validation_info_json: ${text.decode(base64.decode(the_buildResults.metadata.build.results.buildStepOutputs[0]))}

          - validation_info: ${json.decode(validation_info_json)}

          - instance_name: ${validation_info.instance_name}

          - scan_result: ${validation_info.scan_result}

 

    - check_build_status:

        switch:

          - condition: ${len(instance_name) > 0}

            next: return_the_results

        next: build_failed

 

    - build_failed:

        raise:

          message: "Validation instance was not created or validation script failed."

 

    - return_the_results:

        return:

          instance_name: ${instance_name}

          scan_result: ${scan_result}

 

# -------------------------------------------------------------------

#   CREATE VM ONLY (for override pass scenario - creates VM but skips validation)

# -------------------------------------------------------------------

 

create_vm_only:

  params: [image_id, project_id, location_id]

 

  steps:

    - the_build:

        call: googleapis.cloudbuild.v1.projects.builds.create

        args:

          projectId: ${project_id}

          parent: ${"projects/" + project_id + "/locations/global"}

          body:

            steps:

              - name: "gcr.io/cloud-builders/gcloud"

                entrypoint: "bash"

                args:

                  - -c

                  - |

                    set -e

 

                    # Instance name derived from image_id

                    INSTANCE_NAME="${_CANDIDATE_IMAGE}-validation"

 

                    echo "Creating validation VM (override pass - skipping validation scripts): $${INSTANCE_NAME}"

 

                    # Create validation VM from image
                    # Note: Validation scripts are NOT executed (override pass scenario)

                    gcloud compute instances create "$${INSTANCE_NAME}" \
                      --image=projects/sandbox-dev-478813/global/images/${_CANDIDATE_IMAGE} \
                      --machine-type=n1-standard-1 \
                      --subnet=default \
                      --no-address \
                      --service-account=sa-kitchen-sh@sandbox-dev-478813.iam.gserviceaccount.com \
                      --zone=us-central1-a \
                      --scopes=cloud-platform

 

                    echo "VM created successfully. Validation scripts skipped (override pass)."

 

                    # Emit instance name to Cloud Build output

                    echo "{\"instance_name\":\"$${INSTANCE_NAME}\",\"scan_result\":\"Pass\"}" > "$$BUILDER_OUTPUT/output"

 

            substitutions:

              _CANDIDATE_IMAGE: ${image_id}

            options:

              dynamic_substitutions: true

            tags:

              - "schwab-rhel8"

              - "validation_instance"

              - "override_pass"

        result: the_buildResults

 

    - decode_build_result:

        assign:

          - build_output: ${text.decode(base64.decode(the_buildResults.metadata.build.results.buildStepOutputs[0]))}

          - parsed_output: ${text.decode(base64.decode(the_buildResults.metadata.build.results.buildStepOutputs[0]))}

          - instance_name: ${default(json.decode(parsed_output).instance_name, "")}

          - scan_result: ${default(json.decode(parsed_output).scan_result, "Pass")}

 

    - return_result:

        return:

          instance_name: ${instance_name}

          scan_result: ${scan_result}

 

#   CREATE PROMOTED IMAGE (from temp VM)

# -------------------------------------------------------------------

 

create_promoted_image:

  params: [project_id, image_id, validation_instance]

 

  steps:

    - the_build:

        call: googleapis.cloudbuild.v1.projects.builds.create

        args:

          projectId: ${project_id}

          parent: ${"projects/" + project_id + "/locations/global"}

          body:

            steps:

              - name: "gcr.io/cloud-builders/gcloud"

                entrypoint: "bash"

                args:

                  - -c

                  - |

                    set -e

 

                    INSTANCE_NAME="${_VALIDATION_INSTANCE}"

                    PROMOTED_IMAGE_NAME="${_IMAGE_ID}-promoted-$(date +%Y%m%d-%H%M%S)"

 

                    echo "Stopping VM $${INSTANCE_NAME} before creating image..."

                    gcloud compute instances stop "$${INSTANCE_NAME}" \

                      --zone=us-central1-a \

                      --quiet



                    echo "Getting disk name from VM $${INSTANCE_NAME}..."

                    DISK_PATH=$(gcloud compute instances describe "$${INSTANCE_NAME}" \

                      --zone=us-central1-a \

                      --format="get(disks[0].source)")

                    DISK_NAME=$(basename "$${DISK_PATH}")

                    if [ -z "$${DISK_NAME}" ]; then

                      DISK_NAME="$${INSTANCE_NAME}"

                    fi



                    echo "Creating promoted image $${PROMOTED_IMAGE_NAME} from disk $${DISK_NAME}..."

                    gcloud compute images create "$${PROMOTED_IMAGE_NAME}" \

                      --source-disk="$${DISK_NAME}" \

                      --source-disk-zone=us-central1-a \

                      --project=${project_id} \

                      --description="Promoted image from validated VM" \

                      --family="rhel9-runtime" \

                      --labels=source_image="${_IMAGE_ID}",validation_status="passed"

 

                    echo "Promoted image created: $${PROMOTED_IMAGE_NAME}"

                    echo "{\"promoted_image\":\"$${PROMOTED_IMAGE_NAME}\"}" > "$$BUILDER_OUTPUT/output"

 

            substitutions:

              _VALIDATION_INSTANCE: ${validation_instance}

              _IMAGE_ID: ${image_id}

            options:

              dynamic_substitutions: true

            tags:

              - "schwab-rhel8"

              - "promote_image"

        result: the_buildResults

 

    - decode_build_result:

        assign:

          - build_output: ${text.decode(base64.decode(the_buildResults.metadata.build.results.buildStepOutputs[0]))}

          - parsed_output: ${json.decode(build_output)}

          - promoted_image: ${parsed_output.promoted_image}

 

    - return_result:

        return:

          promoted_image: ${promoted_image}

 

#   CLEANUP PIPELINE (unchanged – still reusable)

# -------------------------------------------------------------------

 

cleanup_artifacts:

  params: [image_id, project_id, location_id, instance_name, skip_destroy, scan_result]

 

  steps:

    - skip_instance_creation:

        switch:

          - condition: ${skip_destroy}

            next: return_skipped

 

    - delete_instance:

        call: googleapis.cloudbuild.v1.projects.builds.create

        args:

          projectId: ${project_id}

          parent: ${"projects/" + project_id + "/locations/global"}

          body:

            steps:

              - name: "gcr.io/cloud-builders/gcloud"

                entrypoint: "bash"

                args:

                  - -c

                  - |

                    gcloud compute instances stop ${_INSTANCE_NAME} --zone us-central1-a

                    gcloud compute instances delete ${_INSTANCE_NAME} --zone us-central1-a --quiet

            substitutions:

              _INSTANCE_NAME: ${instance_name}

            options:

              dynamic_substitutions: true

            tags:

              - "schwab-rhel8"

              - "delete_instance"

        result: delete_instanceResults

 

    - delete_image:

        call: googleapis.cloudbuild.v1.projects.builds.create

        args:

          projectId: ${project_id}

          parent: ${"projects/" + project_id + "/locations/global"}

          body:

            steps:

              - name: "gcr.io/cloud-builders/gcloud"

                entrypoint: "bash"

                args:

                  - -c

                  - |

                    if [ "${_SCAN_FAIL}" != "Pass" ]; then

                      gcloud logging write FAILED-SCAN-LOG "Validation failed for ${_CANDIDATE_IMAGE}" --severity "WARNING"

                    fi

 

                    gcloud compute images delete ${_CANDIDATE_IMAGE} --quiet

            substitutions:

              _SCAN_FAIL: ${scan_result}

              _CANDIDATE_IMAGE: ${image_id}

            options:

              dynamic_substitutions: true

            tags:

              - "schwab-rhel8"

              - "delete_image"

        result: delete_imageResults

 

    - return_cleanup:

        return:

          instance_cleanup: ${delete_instanceResults}

          image_cleanup: ${delete_imageResults}

 

    - return_skipped:

        return:

          instance_cleanup: "skipped"

          image_cleanup: "skipped"

 

# -------------------------------------------------------------------

#   CHECK VM DELETION STATUS (Poll until VM is deleted or timeout)

# -------------------------------------------------------------------

 

check_vm_deleted:

  params: [project_id, instance_name, max_attempts, wait_seconds]

 

  steps:

    - init_polling:

        assign:

          - attempt: 1

          - vm_deleted: false

 

    - poll_loop:

        try:

          call: googleapis.compute.v1.instances.get

          args:

            project: ${project_id}

            zone: "us-central1-a"

            instance: ${instance_name}

          result: vm_instance

        except:

          as: e

          assign:

            - vm_deleted: true

        next: check_if_deleted

 

    - check_if_deleted:

        switch:

          - condition: ${vm_deleted == true}

            next: return_deleted

        next: check_status

 

    - check_status:

        switch:

          - condition: ${vm_instance.status == "TERMINATED"}

            assign:

              - vm_deleted: true

            next: return_deleted

        next: increment_and_retry

 

    - increment_and_retry:

        assign:

          - attempt: ${attempt + 1}

        next: check_max_attempts

 

    - check_max_attempts:

        switch:

          - condition: ${attempt >= max_attempts}

            next: return_timeout

        next: wait_before_retry

 

    - wait_before_retry:

        call: sys.sleep

        args:

          seconds: ${wait_seconds}

        next: poll_loop

 

    - return_deleted:

        return:

          vm_deleted: true

          status: "deleted"

          attempts: ${attempt}

 

    - return_timeout:

        return:

          vm_deleted: false

          status: "timeout"

          attempts: ${attempt}

          message: "VM deletion not completed within timeout period"

